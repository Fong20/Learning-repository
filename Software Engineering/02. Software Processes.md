# 02. Software Processes
Software Process is defined as a structured set of activities required to develop a software system. 

## Key aspects of software processes
- Software Specification – Defining the function of the software and its limitations
- Software Design and implementation – defining the organization of the system and implementing the system;
- Software Validation – Checking if the software meets the customer requirements
- Software Evolution – Ensure that the software is written in a way which is adaptable to changing customer needs.

## Software process descriptions
- Software process descriptions are defined as the activities performed in each of the process
- Eg: specifying a data model, designing a user interface, etc. and the ordering of these activities.

**Software process descriptions could also include:**
- Products. Outcome of a process activity
- Roles. Who is involved in the process and what are their responsibilities?
- Pre-post conditions. Statements that are true before and after a process activity has been enacted or a product produced.  

## Plan-driven vs Agile Process
Before we dive into the types of software process models, we need to identify the difference between plan-driven process and agile process.

### Plan-driven
- Plan-driven process is a process where process activities are planned in advance and progress is measured against this plan.
- It is always planned, and the results are shown at the end of the product.

### Agile
- Agile process planning is incremental and it is easier to change the process to reflect changing customer requirements.
- It is basically a process-based method where one can alter the way things and planning and replace them with the more suitable ones.

In practice, most practical processes include elements of both plan-driven and agile approaches. Hence, there are no right or wrong software processes.

## Software process models
A software process model is an **abstract representation** of a process. These models serve as blueprints that guide developers, designers, and stakeholders through the system’s structure, behavior, and functionality.

**Types of software process models**
1. Waterfall model
2. Incremental development model 
3. Integration and configuration model

In practice, most large systems are developed using a process that incorporates elements from all of these models.

### Waterfall model
- Normally used when the requirements are well-understood and there are limited changes during the design process.
- The core principle of waterfall model is that a phase has to be completed before moving onto the next phase.
- It is a plan-driven model

**Phases in waterfall model:**
- Requirements analysis and definition = Requirements of the system are collected and documented. 
- System and software design = Defines how the software will be built. Eg: Prepare the blueprint of the software system so that no problems are faced in the coming phases and solutions to all the requirements in the requirement phase are found.
- Implementation and unit testing = The development of software is carried out. Eg: Coding, debugging, implementing database etc
- Integration and system testing = The software is verified and evaluated through various testing phases to ensure that we have created the right product.
- Operation and maintenance = Process of taking care of the finished software and maintaining it as per time once it is utilized by the users

![image](https://github.com/user-attachments/assets/0aacf607-e9e5-4c9f-99fb-d97748488ad7)

Advantages of waterfall model
- simple and easy to understand as each phase of this model is well explained.
- The end goal is determined early.


**Drawbacks of waterfall model**
- Rigid and not flexible. It is the difficult to accommodate change after the process is underway. Any updates will need to be restarted from the initial phase
- Time-consuming. As any updates made will need to be restarted from the initial phase, it is also time consuming

Therefore, this model is only appropriate when the requirements are well-understood and changes will be fairly limited during the design process. 

### Incremental development model
- Rather than deliver the system as a single delivery in waterfall model, the development and delivery process is broken down into increments with each increment delivering part of the required functionality.
- User requirements are prioritised and the highest priority requirements are included in early increments
- It may be a plan-driven model or agile model

**Process:**
- It starts by developing an initial implementation, then user feedback is taken on it, and it is developed through several versions until an accepted system is developed. Important functionalities of the software are developed in the initial iterations.
- Each subsequent release of a software module adds functions to the previous release. This process continues until the final software is obtained.
- For example, we collect the customer's requirements, now instead of making the entire software at once, we first take some requirements and based on them create a module or function of the software and deliver it to the customer. Then we take some more requirements and based on them add another module to that software until the complete system is created.

![image](https://github.com/user-attachments/assets/b51b48c2-6855-4809-a279-5005aa084ddd)

**Incremental development**
- Develop the system in increments and evaluate each increment before proceeding to the development of the next increment
- Evaluation is then done by user/customer proxy.

**Advantages**
- The cost of accommodating changing customer requirements is reduced. The amount of analysis and documentation that has to be redone is much less than is required with the waterfall model.
- It is easier to get customer feedback on the development work that has been done. Customers can comment on demonstrations of the software and see how much has been implemented.
- More rapid delivery and deployment of useful software to the customer is possible. Customers are able to use and gain value from the software earlier than is possible with a waterfall process. 

**Disadvantages**
- System structure tends to degrade as new increments are added.  Unless time and money is spent on refactoring to improve the software, regular change tends to corrupt its structure. Incorporating further software changes becomes increasingly difficult and costly. 

**Incremental delivery**
- Deploy an increment for use by end-users;
- More realistic evaluation about practical use of software;
- Difficult to implement for replacement systems as increments have less functionality than the system being replaced.

![image](https://github.com/user-attachments/assets/a03cc74e-6622-4dce-a0c5-43d359141f87)

### Integration and configuration model (reuse and configure)
- Based on software reuse where systems are integrated from existing components or application systems
- Reused elements may be configured to adapt their behaviour and functionality to a user’s requirements
- It may be a plan-driven model or agile model

**Types of reusable software:**
- Stand-alone application systems (COTS)
- Objects developed in a package
- Web services

![image](https://github.com/user-attachments/assets/80eea59c-45b6-420b-9bb0-8e60b21526eb)

### Software Prototyping model
A prototype is an initial version of a system used to demonstrate concepts and try out design options.

A prototype can be used in:
- The requirements engineering process to help with requirements elicitation and validation;
- In design processes to explore options and develop a UI design;
- In the testing process to run back-to-back tests.

### Benefits of prototyping
- Improved system usability.
- A closer match to users’ real needs.
- Improved design quality.
- Improved maintainability.
- Reduced development effort.

**Process of prototype development**

![image](https://github.com/user-attachments/assets/70c5f216-5234-440c-ba90-8cf0d51cf765)

## Process activities

### Requirement engineering process

