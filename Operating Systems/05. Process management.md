# 05. Process management

## Process
  ### Concept of a process
  - Process are **programs which are currently being executed (currently running)**
  - A program becomes a process when standby tasks (interruption) are performed to run the executable file and the executable file is loaded into the memory.
  - Therefore, a process has to be created in order for the program to run
  -  There can be multiple processes from the same program. Although two processes may be associated with the same program, thay are considred as two separate processes (Example: when we run two chrome web browsers, the program code will be identical but the data, heap and stack sessions will be different)
  
  ### Information in a process
  Generally, a process contains the program code and other information. The information can be divided into four sections:
  - text (program code)
  - stack
  - data
  - heap
  
    ### Text
    - Contains the program code
    - It also contains the current activity represented by the value of the program counter
   
    ### Stack
    Contains temporary data, such as function parameters, return addresses and local variables

    ### Data 
    Contains the global variable

    ### Heap 
    Dynamically allocates memory to process during its run time

    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/3aa3e89b-deba-41b9-ae87-c311878b6255)

  ### Process states
  As a process is being executed, it changes state. The process could be in one of the following states:
  - New: Newly Created Process (or) being-created process.
  - Ready: After the creation, process moves to the Ready state, i.e. the process is waiting to be assigned to the processor for execution.
  - Run: The process is executed in CPU (only one process at a time can be under execution in a single processor)
  - Wait (or Block): The process is waiting for some events to occur.
  - Complete (or Terminated): The process completed its execution.
  
    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/a1016fdc-8518-4a61-94b4-cfcdb864ef82)
  
  Note:
  - Only one process can be in running state on a single processing core at any instant (
  - If there are additional processes which are waiting to be processed by the processor, it can be in either the ready state or waiting state

## Process control block (PCB)
- A process control block (PCB) is a **data structure used by operating systems to store important information about running processes.**
- PCB is also known as the task control block (TCB).
- It acts as the **identofication for each process, each process in the OS is represented by a PCB.**
- The PCB is created and managed by the OS

  ### Components of a PCB
  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/4df03e56-108c-4507-bf08-93071b9dad35)

## Process table
The process table is **an array of PCBs, which means it logically contains a PCB for all of the current processes in the system.**

## Process management
Most of the time, we are running multiple processes. Thus, it is crucial to ensure that the processes are **organized efficiently to ensure that the CPU is utilized efficiently (busy all the time)** and **ensure that each process will eventually get its turn to run**

To ensure that the CPU is properly utilzied to execute multiple processes, we use two techniques:

  ### Multi-programming
  - The CPU **switch and executes another program when the current program enters the waiting state**
  - Multi-programming **does not allow the user to interact with all the processes that are currently sitting inside the memory.** The **user can only interact with the process which is currently running.**
  
    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/1c9b95cb-7c63-4e93-af3f-cebdd72e34b2)
  
  ### Time-sharing 
  - In cases where there are many waiting processes in the memory, these waiting processes might not get the chance to be run if the current running process never finish its execution.
  - **Time sharing technique solves this problem by allocating specific processing time (equal time interval) for each process to be executed by the CPU.** If the process cannot be executed finish within the given time, the CPU will move on and execute another process instead.
  - Time sharing is beneficial in running multi-application
  
  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/e9a52e55-e503-412a-8842-ec91e2ff692e)

## Process creation and termination

  ### Process creation
  - The new state in the process state is known as process creation
  - A unique process identifier (PID) is assigned to the new process
  - memory space is also allocated to the process to store program code, pcb, stack etc
  
  ### Process termination
  - Process executes the last statement and requests the OS to delete it
  - Resources are then de-allocated by the OS so they can be allocated to other processes which are waiting for the resources.

## Process queueing
- Process ququeing decribes **how the processes are queued for the CPU to execute.**
- A process which is waiting for CPU to execute will be placed into a queue

  ### How it works?
  - Process queueing works based on the scheduling algorithm. Based on the scheduling algorithm, the short-term scheduler selects a process in the ready state for the CPU to execute.
  - A linked list is used to keep track of all processes in a queue

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/05957095-8517-46f5-be14-ddacceff273b)

  ### Types of queue
  - **Job queue** = Consists of all processes in the system
  - **Ready queue** = Processes which are ready to be executed
  - **Device queue** = Processes which are waiting for I/0 device

## Process scheduling
- Describes the life cycle of a process
- A process can migrate among various queues throughout its lifetime, scheduling of process is done through different schedulers.
  
  ### Queueing diagram
  - A queueing diagram is a **common visual representation of a scheduling process**
  - Rectangle box represents a queue or event
  - Circle represents the resource that serve the queue
  - Arrows indicate the flow of processes

  Example:
  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/ddf92047-af5f-4a41-a328-f94f0e56f5f9)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/5896d644-fe34-4194-9fca-72d11c2f0ee5)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/f53264b9-8214-4930-92c3-3af24e0a0a3e)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/ef675d87-e3a1-4a71-ad95-6509d221f3e9)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/60a90309-8660-4be7-b1ca-72e1c0957039)

  ### Types of schedulers
  The scheduling process can be handled by different schedulers
  - **short-term:** Selects a process from ready queue to be executed by the CPU
  - **long-term:** Select a process to be brought to ready queue
  - **medium-term:** Determine processes which should be terminated or resumed (Eg: crashed program)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/dfeaa186-eb97-4182-8e52-51d9cdca9c37)

    ### Short-term schedulers
    - A short-term scheduler **selects a process that is in ready queue to be executed**
    - it must select a new process for the CPU frequently as ot needs to select a process whenever the CPU has nothing to execute.

    **CPU scheduling decisions may take place when a process**
    1. switches from running state to waiting state
    2. is terminated
    3. switches from running state to ready state ( process did not finish executing within the specific time frame)
    4. switches from waiting state to ready state.

    ### Long-term scheduler
    - Select a pricess to be brought to ready queue
    - It executes much less frequently compared to short-term scheduler
      
    ### Short-term vs Long-term scheduler
    - There needs to be a balance between I/O bound process nad CPU-bound process
    - I/O bound process spends more time doing I/O than compputations whereas CPU-bound process spends more time doing computations
    - If there are too many I/O bound processes, the ready queue will be almost empty and the short-term scheduler will have only few processes to select
    - If there are too many CPU bound processes selected, the device queue will be almost empty and the devices will have no work to do

    ### Medium-term scheduling
    - **Determines which processes to be suspended or resumed**
    - It also **swaps out inactive processes to create memory space for others**
    - The **contents of the suspended process will be stored back to the hard disk** which **allows the process to be reintroduced into the memory and continue execution from where it left off.**

    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/d5066936-35a2-480c-a271-95586a4e76bb)

    ### Dispatcher
    A dispatcher **gives control of the CPU to the process selected by the short-term scheduler**
  
    These tasks include:
    - perform context switching
    - switching back to user mode
    - jump to the proper location in the user program to start or restart the program

     ![image](https://github.com/Fong20/Learning-repository/assets/150316121/1dd25ff8-bed8-4c0c-8375-22cb4872d596)
  
  ### Scheduling criteria
  Scheduling criterias are **criterias to be taken into consideration when selecting the algorithm to be used.**

    ### Criterias
    - CPU utilization (Ensure that the CPU is kept busy all the time)
    - Throughput (How many processes which can be executed by the CPU in one second)
    - Turnaround time (Time from the submission of a process at ready queue to the time of completion)
    - Waiting time (Time in which a process has been waiting in the ready queue)
    - Response time (Time it takes from when a request was submitted to the first response provided)
    - burst time = execution time

   - The more criterias we want to meet, the more complicated the calculation will be.
   - Generally, we want to **increase CPU utilization and throughput** while **minimizing turnaround time, waiting time and response time.**
  
  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/4cc57cc8-ed24-4313-b553-6861746354b7)
  
    ### Steps to calculate algorithm
    - **Draw a gantt chart to show the sequence of the processes**
    - **calculate the waiting time and turnaround time**
    - waiting time = start time - arrival time
    - turnaround time = completion time - arrival time

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/34c404b7-965a-4f37-bec9-75edd6caf8ba)

## Scheduling algorithm
- first come first served (FCFS)
- shortest job first (SJF)
- priority scheduling (Pr)
- round robin (RR)

  ### First come first serve (FCFS)
  - FCFS is the simplest CPU scheduling algorithm that schedules according to arrival times of processes.
  - The first come first serve scheduling algorithm states that the process that requests the CPU first is allocated the CPU first.

   **Example 1: Assuming that the processes arrive in the order P1, P2 and P3 and the arrival time is the same for all processes.**
  
  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/5e749c60-f356-4e6e-a241-56f6b1e177a7)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/a63e24ca-b956-46d5-b259-25d5cdbb872a)
  
  **Example 2: Processes arrive in different order, P2, P3 and P1 but the arrival time for each process is still the same.**

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/fd58f2dc-44c8-4e2f-b981-dd57b956b312)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/b41ab522-a45d-43a4-9068-df95d586703c)

  **Important observation:**
  - Based on the results calculated from example 1 and example 2, example 2 is much efficient than example 1 as it has lower average waiting time and turnaround time.
  - This is due to the **scheduling of processes.** The **process with the shortest burst time must be at scheduled at the front** whereas the **process with the longest burst time must be arranged at the back when the arrival time is the same**
  -  **Example 1 experiences convoy effect**, whereby **the short process is arranged behind the long process.** This will **cause longer waiting time and turnaround time of the short processes.** Not only that, the short process at the back might not get executed. 

  **Example 3: Processes with different arrival time**
  
  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/ac2850e8-e8d7-402a-8369-e573bb6cfe56)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/fe6b8913-c1c0-413b-9292-75c5f7497e20)

  ### Shortest Job First (SJF)
  - **Processes are scheduled to be executed based on its burst time. The process with the shorter burst time will be executed first**
  - Uses the next CPU burst time to schedule the process with the shortest time
  - SJF's advantage is **its minimum average waiting time among all other schduling algorithms** but **it has difficulties in knowing the exact length (Burst time) of the next CPU request**
  - It can only estimate the length by using the length of the previous CPU burst time.

  **Example 1: All processes have the same arrival time.**

  If the arrival time is equal for all processes, we can just directly schedule the processes to be executed based on the their burst time (shortest burst time to longer burst time)
  
  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/1a000ed6-1e99-46a3-944b-60f33d6803e9)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/3718a6c0-f483-4c53-bcd0-c7c859222bcb)


  **Example 3: Processes arrive in different time**

  If there are different arrival times for each process, the **first process to be executed will always be the process with arrival time of 0.** After that, we **schedule the process to be executed after the first process by comparing the burst time of the processes in the waiting queue.**

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/383a92d7-f9ad-44a4-9959-96ca0427fee2)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/f99d4198-2dda-448f-bc0e-d66207b35d17)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/b95f5770-da0c-4ab0-9e0d-b1106219a129)

  ![image](https://github.com/Fong20/Learning-repository/assets/150316121/6bc16757-c9a7-44b5-9aa3-fe1f136ce3dc)


  ### Priority Scheduling
  - **In priority scheduling, the CPU is allocated to the process with the highest priority.**
  - **Processes with the same priority are executed on a first-come first served basis.**
  - It can be divided into two types: preemptive and non-preemptive
  - The lower the priority number, the higher the priority
  
    ### Types of priority scheduling
  - **Non-preemptive = A running process cannot be interrupted by another process**
  - **Preemtive = A running processs can be interrupted by another process with higher priority**

    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/cda26712-6f52-4a6a-8ab1-5967eae18a42)
 
    ### Aging process
    **One of the downsides of priority scheduling is that low priority scheduling processes might not get the chance to be run.** Aging process solves this problem by **increasing the priority of the process as time progresses.**

    **Example 1: Non-preemptive priority scheduling with same arrival time**
    
    If the arrival time is the same, we schedule the processes to be executed based on the priority number.
 
    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/ece570f7-7db2-4667-9d3b-c29f53b975af)
 
    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/30f927d6-e4cf-455f-98e1-93f42fad9bd8)

    **Example 3: non-preemptive case with different arrival times**
    
    If the arrival time is different for each process, the first process will always have arrival time of 0. Once the first process is finished executed, the next process is allocated to the CPU by comparing the priority number of the processes located in the waiting state.

    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/925eeb57-d85e-4033-9f24-e54fb47973d7)

    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/d9d7ea46-5b4e-4771-818a-05d2e98a3e2b)

    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/a0b602b0-37f9-491d-ad15-c4f7ce82f8e5)

    **Example 4: Preemptive with different arrival time**
    
    The first step is to list down all the process based on the arrival time. Next, check if the priority number is higher than the current first process. If it is higher, then it will run the process with the higher priority first. Otherwise, select the process with the lower priority to be the next process to be run after the first process.

    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/589da514-3439-46d8-b478-981f4cda3441)

    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/489df9b5-a257-4c93-997b-ca0de81d70f3)

    ![image](https://github.com/Fong20/Learning-repository/assets/150316121/ea6ea5eb-8079-4159-937c-2f112190056d)

### Round Robin (RR)
- Round robin is using the time sharing process management where each process is allocated a small unit of CPU time (time slice/quantum). If the time has elapsed, the process will be preempted and added to the end of the ready queue.
- If the time slice is allocated too large, the scheduling becomes such like FCFS
- If the time slice is allocated too small, there will be a lot of overhead due to increase in context switching.

Whenever the time slice expires, the exitsting process will be transitioned from running state to ready queue and the next process will be executed 

The arrival time of the new process determine the position in the ready queue
![Screen Shot 05-24-24 at 10 59 AM](https://github.com/Fong20/Learning-repository/assets/150316121/603f2cde-6f87-4d20-a1ca-fb986cec85f0)

![Screen Shot 05-24-24 at 11 00 AM](https://github.com/Fong20/Learning-repository/assets/150316121/05e4aa01-c18b-4674-9e22-781197dd0ccb)

![Screen Shot 05-24-24 at 11 08 AM](https://github.com/Fong20/Learning-repository/assets/150316121/c41bad4a-af3f-4258-9b23-4a02d7ba3eef)

**Example 1: Round robin algorithm with equal arrival time and time slice of 4**

![Screen Shot 05-24-24 at 11 19 AM](https://github.com/Fong20/Learning-repository/assets/150316121/f2b16151-227e-4fee-93eb-172b86881f33)

![image](https://github.com/Fong20/Learning-repository/assets/150316121/2ce04aef-699c-4bbf-a2a0-852edfc79071)

**Example 2: Round robin scheduling algorithm with different arrival time and time slice of 4**

![image](https://github.com/Fong20/Learning-repository/assets/150316121/c47b7541-ab6f-449e-a9da-cfec3ce8512b)




