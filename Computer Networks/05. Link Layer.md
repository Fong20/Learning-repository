# 05. Link Layer

## Function of link layer
1. Addressing = Assigning and managing unique hardware address (MAC adddresses)
2. Framing = Dividing data into frames for transmission over a physical medium
3. Encapsulation = Encapsulates the datagram by Adding link layer header and trailer to create a frame
4. Medium access control = mechanism which determines how shared medium is accessed by multiple users without collision
5. Error detection and correction = detecting errors in the transmitted frame by using methods such as cyclic redundancy check (CRC), checksum etc 

## Frames
- A layer 2 packet
- It is created by encapsulating the datagram with link layer header and trailer

## Error detection and correction

### Sources of errors
- Errors are normally cause by signal attenuation and noise
- Signal attenuation = reduction in the signal strength / signal intensity as it travels through the medium. As the signal travels through a longer distance, there is higher tendency that the signal will lose its energy. It can also be due to transmission medium as each transmission medium have different signal attenuation
- Noise = random / unwanted interferrence from external sources which disrupts the signal

### Error detection and correction techniques
- The key concept to error detection is by adding additional bits (parity bits in parity check / redundant bits in CRC) which to the original data for error detection means
- Error detection is not 100% reliable as it may miss some errors. However, it is utilized to reduce the amount of errors and ensure that it does not exceed the receiver's sensitivity.
- There are several error detection and correction techniques which are used to check for any errors within the received frame and notify the receiver node.

1. Parity check
2. Checksumming
3. Cyclic redundancy check (CRC)

**Once the receiver node detects an error, it can either:**
- inform the sendor node to retranmit the frame
- correct the bit error

**Example of error detection process**

![image](https://github.com/user-attachments/assets/02321312-2b52-4921-8803-1430ae94a0da)

### Parity check
Parity check is a simple technique which is used to detect errors in a frame

**Important terms in parity check:**
1. d = data in bits
2. parity = 1 bit
   
**There are two types of parity check:**
1. Single bit parity
2. Two-dimensional parity

**Single bit parity**
- Single bit parity only detects single bit error
- Single bit parity can be further divided into two types which are even parity and odd parity. We can choose to implement either odd parity or even parity for error detection, there is no fixed use cases for each parity.

1. **Even parity**
- In even parity, the total number of 1 after adding parity bit (d + 1) is even

2. **Odd parity**
- In odd parity, the total number of 1 after adding parity bit (d + 1) is odd

**Example:**

There are 9 1's in the data bit. As a result, we do not need to add 1 in the parity bit as it will make it an even parity (10 bits)

![image](https://github.com/user-attachments/assets/9f6a2150-005d-4e73-bac2-76ae37ccbcea)

**Two-dimensional parity**
- In two-dimensional parity, the data is divided into rows (i) and columns (j) and the parity will be added for each dimension (row and column)
- It detects and corrects single bit error

![image](https://github.com/user-attachments/assets/2d4ae8ea-88ab-43fa-97d1-5f2aa1b0c6c2)

**Example:**
- In this case, the sender is using even parity for error detection. Thus, each row and column must have an even number of 1's after adding the parity bit. The data is then sent to the receiver.
- As the data is being received by the receiver, it knows that it is using even parity is used for error detection and checks if the bits of each column and row is even.
- It turns out there is a single bit error on the row 2 and column 2 as the number of 1's is not even as according to the sender which uses even parity. As a result, the receiver knows that there is an error in the received frame.

![image](https://github.com/user-attachments/assets/3da8e3b6-39d1-4771-800e-0b6ba06584da)

**Disadvantages of parity check**
- It only detects for errors but do not correct them
- It cannot detect even number of bit error. When there are an even number of bits which are different from the sender's bits, it cannot detect that it has an error.

### Cyclic redundancy check (CRC)

**Important terms in CRC:**
1. D = data bits to be sent, d bits
2. R = redundancy bits, r bits
3. G = generator polynomial, it is basically the dividor which is used to find the remainder

**CRC technique to find the redundancy bits at the sender side**
1. Add 0's to the data to be sent, D. The amount of 0's to be added to the data is determined by subtracting the number of bits of generator polynomial, G by 1.
2. Divide the data, D by the generator polynomial, G and perform binary XOR operation
3. The remainder will be the redundancy bits, R. The number of redundancy bits must be equivalent to the number of 0's added to the original data. Eg: If 3 bits are added to the original bits, the redundancy bits must also be 3 bits
4. The redundancy bits, R are added to the original data bits, D, (D + R)

**Example:**

![image](https://github.com/user-attachments/assets/73e8f7d7-78dd-43f6-a7e7-1197e49434b9)


