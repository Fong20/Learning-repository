# 04. Processes, Threads, Interprocess Communication

- Processor: Provides a set of instructions along with the capability of automatically executing a series of those instructions.
- Thread: A minimal software processor in whose context a series of instructions can be executed. Saving a thread context implies stopping the current execution and saving all the data needed to continue the execution at a later stage.
- Process: A software processor in whose context one or more threads may be executed. Executing a thread, means executing a series of instructions in the context of that thread.

Example:
= For a computer that is running a spreadsheet program and a word processor:
both spreadsheet and word processor are separated processes,
- within the spreadsheet that comprises many cells with functional dependencies among each other, both recalculation of cells value and interaction with user are separated threads, and
- within the word processor, both spelling checker and user input handling are separated threads.

## Context Switching 
- Processor context: The minimal collection of values stored in the registers of a processor used for the execution of a series of instructions (e.g., stack pointer, addressing registers, program counter).
- Thread context: The minimal collection of values stored in registers and memory, used for the execution of a series of instructions (i.e., processor context, state).
- Process context: The minimal collection of values stored in registers and memory, used for the execution of a thread (i.e., thread context, but now also at least MMU register values).

<img width="832" height="323" alt="image" src="https://github.com/user-attachments/assets/0dc3f463-9a51-4fab-88b1-bfc81b62d4b0" />

## Threads
Threads share the same address space. Thread context switching can be done entirely independent of the operating system.
•
Process switching is generally more expensive as it involves getting the OS in the loop, i.e., trapping to the kernel.
•
Creating and destroying threads is much cheaper than doing so for processes.

### Solaris Threads
- Introduce a two-level threading approach: lightweight processes that can execute user-level threads.
- Combining kernel-level lightweight processes and user-level threads.

User-level thread does system call
- the LWP that is executing that thread, blocks.
The thread remains bound to the LWP.
•
The kernel can schedule another LWP having a runnable thread bound to it.
-
Note: this thread can switch to any other runnable thread currently in user space.
•
A thread calls a blocking user-level operation
-
do context switch to a runnable thread, (then bound to the same LWP).
•
When there are no threads to schedule, an LWP may remain idle, and may even be removed (destroyed) by the kernel.

<img width="602" height="262" alt="image" src="https://github.com/user-attachments/assets/92c6fb94-aac8-4c7b-bc21-2a223e472abc" />

### Threads and Distributed Systems

3 ways to organize a server
1. Dispatcher/worker model
- Multi-threaded servers organised as dispatcher/worker model
- dispatcher reads incoming request for file operations
- an idle worker received the request from dispatcher and performs a blocking read from the local file system

<img width="456" height="240" alt="image" src="https://github.com/user-attachments/assets/8f28f672-1534-4c53-a994-0c6caf1b6189" />

2. single-thread process (non-parallelism, blocking system calls)
- main loop handles request, performs read, before getting the subsequent requests, in blocking manner

3. finite-state machine (parallelism, non-blocking system calls)
- single thread with execution states been recorded
- thread reads a message (e.g. file request, or call returned from disk), processes and stores the state of computation

## Virtualisation
creates a standardized platform which helps to convert to other platforms
Eg: Java virtual machine (JVM)

## Client and Server 

### Server
A server is a process that waits for incoming service requests at a specific transport address. In practice, there is a one-to-one mapping between a port and a service.

#### Types of Server
1. Superservers: Servers that listen to several ports, i.e., provide several independent services. In practice, when a service request comes in, they start a subprocess to handle the request (UNIX inetd)
2. Iterative servers: Iterative servers can handle only one client at a time, in contrast to concurrent servers
3. concurrent servers:

Example: 

<img width="639" height="350" alt="image" src="https://github.com/user-attachments/assets/7e1d3815-71ab-481d-b689-28ea278bcb15" />

## Synchronous vs Asynchronous communication
In synchronous communication, the sender can only send another message when the receiver receives the message

<img width="815" height="350" alt="image" src="https://github.com/user-attachments/assets/2b3352f9-6619-4317-9d63-9c582f41c583" />

in asynchronous communication,  the sender does not need to wait for an acknowledgement from receiver to send another message.

<img width="815" height="350" alt="image" src="https://github.com/user-attachments/assets/c059d36d-4b10-4515-93b4-d050260224df" />

## Sockets and Ports
In the IPs, messages are sent to (Internet address, local port) pairs.
-
There are 216 possible port numbers
-
A process cannot share ports with other processes on the same computer
-
However, any number of processes may send messages to the same port.

<img width="815" height="350" alt="image" src="https://github.com/user-attachments/assets/0991c42c-ff88-449d-83bd-94a43d61ae56" />
