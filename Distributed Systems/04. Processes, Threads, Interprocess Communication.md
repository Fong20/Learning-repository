# 04. Processes, Threads, Interprocess Communication

- Processor: Provides a set of instructions along with the capability of automatically executing a series of those instructions.
- Thread: A minimal software processor in whose context a series of instructions can be executed. Saving a thread context implies stopping the current execution and saving all the data needed to continue the execution at a later stage.
- Process: A software processor in whose context one or more threads may be executed. Executing a thread, means executing a series of instructions in the context of that thread.

Example:
= For a computer that is running a spreadsheet program and a word processor:
both spreadsheet and word processor are separated processes,
- within the spreadsheet that comprises many cells with functional dependencies among each other, both recalculation of cells value and interaction with user are separated threads, and
- within the word processor, both spelling checker and user input handling are separated threads.

## Context Switching 
- Processor context: The minimal collection of values stored in the registers of a processor used for the execution of a series of instructions (e.g., stack pointer, addressing registers, program counter).
- Thread context: The minimal collection of values stored in registers and memory, used for the execution of a series of instructions (i.e., processor context, state).
- Process context: The minimal collection of values stored in registers and memory, used for the execution of a thread (i.e., thread context, but now also at least MMU register values).

<img width="832" height="323" alt="image" src="https://github.com/user-attachments/assets/0dc3f463-9a51-4fab-88b1-bfc81b62d4b0" />

## Threads
- Threads share the same address space. Thread context switching can be done entirely independent of the operating system.
- Process switching is generally more expensive as it involves getting the OS in the loop, i.e., trapping to the kernel.
- Creating and destroying threads is much cheaper than doing so for processes.

### Solaris Threads
- Introduce a two-level threading approach: lightweight processes that can execute user-level threads.
- Combining kernel-level lightweight processes and user-level threads.

- User-level thread does system call. the LWP that is executing that thread, blocks.
- The thread remains bound to the LWP.
- The kernel can schedule another LWP having a runnable thread bound to it. Note: this thread can switch to any other runnable thread currently in user space.
- A thread calls a blocking user-level operation, do context switch to a runnable thread, (then bound to the same LWP).
- When there are no threads to schedule, an LWP may remain idle, and may even be removed (destroyed) by the kernel.

<img width="602" height="262" alt="image" src="https://github.com/user-attachments/assets/92c6fb94-aac8-4c7b-bc21-2a223e472abc" />

### Threads and Distributed Systems

3 ways to organize a server
1. Dispatcher/worker model
- Multi-threaded servers organised as dispatcher/worker model
- dispatcher reads incoming request for file operations
- an idle worker received the request from dispatcher and performs a blocking read from the local file system

<img width="456" height="240" alt="image" src="https://github.com/user-attachments/assets/8f28f672-1534-4c53-a994-0c6caf1b6189" />

2. single-thread process (non-parallelism, blocking system calls)
- main loop handles request, performs read, before getting the subsequent requests, in blocking manner

3. finite-state machine (parallelism, non-blocking system calls)
- single thread with execution states been recorded
- thread reads a message (e.g. file request, or call returned from disk), processes and stores the state of computation

## Virtualisation
creates a standardized platform which helps to convert to other platforms
Eg: Java virtual machine (JVM)

## Client and Server 

### Server
A server is a process that waits for incoming service requests at a specific transport address. In practice, there is a one-to-one mapping between a port and a service.

#### Types of Server
1. Superservers: Servers that listen to several ports, i.e., provide several independent services. In practice, when a service request comes in, they start a subprocess to handle the request (UNIX inetd)
2. Iterative servers: Iterative servers can handle only one client at a time, in contrast to concurrent servers
3. concurrent servers:

Example: 

<img width="639" height="350" alt="image" src="https://github.com/user-attachments/assets/7e1d3815-71ab-481d-b689-28ea278bcb15" />

## Synchronous vs Asynchronous communication
In synchronous communication, the sender can only send another message when the receiver receives the message

<img width="815" height="350" alt="image" src="https://github.com/user-attachments/assets/2b3352f9-6619-4317-9d63-9c582f41c583" />

in asynchronous communication,  the sender does not need to wait for an acknowledgement from receiver to send another message.

<img width="815" height="350" alt="image" src="https://github.com/user-attachments/assets/c059d36d-4b10-4515-93b4-d050260224df" />

## Sockets and Ports

### Sockets
- In the IPs, messages are sent to (Internet address, local port) pairs, known as sockets.
- Socket is basically an endpoint for communication between processes. It is created by the comnbinatio of ip address and port number.
- IPC is basically performed by transmitting message between a socket from one process and a socket in another
- Both UDP and TCP use sockets

Processes:
- Create and bind socket to internet address and local port
- Use the same port for sending and receiving
- do not share ports (exception to IP multicast)

<img width="764" height="255" alt="image" src="https://github.com/user-attachments/assets/b6a12346-5f66-4a5d-a626-866807810cee" />

### Ports
- There are 2^16 possible port numbers
- A process cannot share ports with other processes on the same computer. However, any number of processes may send messages to the same port.

<img width="558" height="442" alt="image" src="https://github.com/user-attachments/assets/5c55baad-bc5c-4e19-a117-8a62b928a230" />

## TCP
- TCP is a connection-oriented and stream-oriented protocol
- It provides reliable communication over packet-switched networks. TCP ensures that a message is sent accurately and in its entirety. If the sender does not receive an acknowledgement within a timeout, it retransmits the message.
- PDU for TCP is known as stream while 

### TCP Socket
- Listening process (server) create a stream socket and binds to the server’s socket address and wait for request
- Server accepts connection and obtain a new socket for communication with client

**Important commands**

**Example: TCP Client-Socket Communication**

<img width="794" height="390" alt="image" src="https://github.com/user-attachments/assets/bc0eac16-3c9e-4f26-a291-77985d2d5efe" />

<img width="794" height="374" alt="image" src="https://github.com/user-attachments/assets/d616ffde-d562-49d1-b166-8213717a12f3" />

## UDP
- UDP is a connectionless and best effort protocol, which means it does not guarantee that the packet will be received by the receiver.
- Used when a a reliable delivery is not required.
- It provides very few error recovery services. The application itself must process any errors and check for reliable delivery.
- PDU for UDP is datagram

### UDP Socket
- Socket system call – specify the communication domain (normally the Internet), the type (datagram or stream), and sometimes a particular protocol.
- Before a pair of processes can communicate, the recipient must bind its socket address if it requires a reply.

**Important commands**
1. sendto
- consists of arguments specifying the socket through which the message is to be sent, the message, the socket address of destination
- Eg: sendto(s, "message", ServerAddress) where s is the socket that the message is to be sent

2. recvfrom
- consists of arguments specifying the local socket to receive a message, memory locations for storing, the socket address of the sending socket.
- Eg: amount = recvfrom(s, buffer, from) where s is the local socket to receive the message, buffer is the memory location to store the received data, from is the socket address of the sending socket

**Example: UDP Client-Socket Communication**

<img width="794" height="346" alt="image" src="https://github.com/user-attachments/assets/a0ca7888-000a-47f1-9943-a22d6f44d69c" />
