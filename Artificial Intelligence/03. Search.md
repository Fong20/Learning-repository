# 03. Search
Search is the process of looking for a sequence of actions that reaches the goal.

## Goal
- Goal limits the objectives to achieve and hence the actions to consider.
- Given a goal, the process of problem formulation is to decide the **actions** and **states** to
be used in the problem.

## State
- represents the current condition / situation

## Actions
- Defined as the steps taken to acheive the goal

## Solution
- Defined as a sequence of actions performed to reach the goal from the starting state
- A solution to a problem is an action sequence that leads from the initial state to the goalstate
- An optimal solution is the “best” solution among all solutions.
For

## State space
- is the representation of a problem whereby possible alternative paths leading to a solution can be explored and analysed.
- is constructed with all possible states and actions.
- starting point to creating an algorithm

![image](https://github.com/user-attachments/assets/9ed376ee-149c-428b-854c-4edb37292507)

## Transition model
- is the description of the actions.
- is a function to map one state to another state given an action.
f(current state, action) = next state

## Real-world problems
1. route-finding problems – as the one of Nick in Romania
2. touring problems – visit every point at least once, starting and ending in a specific city
3. traveling salesperson problem (TSP) – a touring problem with each point must be visited exactly only once
4. VLSI layout problem – to position millions of components and connections on a chip to minimise area, maximise production,... . . .
5. robot navigation – a more general route-finding problem

## Process of solving problem using search
To solve the problem using search, we need to go through the following process:

Step 1: Goal formulation
Step 2: Problem formulation
Step 3: Solution identification

## Search algorithms
Different search algorithms are useful to identify optimal solutions with different criteria of “best”.

### Five components 
- Initial state = the state the agent starts in
- Actions – the actions available to the agent
- Transition model – description of what each action does
- Goal test – a test to determine if a given state is a goal state
- Path cost – calculate numerical cost of a path (a series of actions) to reflect performance measure

### Types of search algorithms
1. Uninformed search = not given any information
2. Informed search
3. same search

## Uninformed Search
- also known as blind search because there's no additional information provided.
- It uses strategies with no additional information beyond the problem's definition.

### Types of Uninformed Search
- Breadth-first search (BFS)
- Depth-first search (DFS)
- Uniform-cost search (UCS)

### Breadth-first search (BFS)
Root node = starting node

Frontier node = node which does not have any other options (child nodes)

As the goal is reached, the algorithm ends

**How it works:**
1. Expand root node
2. Expand all successors of root node at the same level
3. Continue expanding the successors of the successors

Note: If there exist redundant nodes in the same level, remove the child node which is found later

![image](https://github.com/user-attachments/assets/38728287-5519-44ec-a8b3-c08d9804efbd)

### Depth-first search (DFS)
Depth-first search (DFS) expands the deepest node in the current frontier of the search tree.

**Example: Reach node M using DFS**

The nodes on the left regardless of each level is always the first node for the particular level. In this case, it is A,B,D and H.

![image](https://github.com/user-attachments/assets/57ba3501-f128-4e8b-aa82-f2a12072d6f7)

The explored nodes which do not match the goal will be eliminated

![image](https://github.com/user-attachments/assets/9fb8d32f-cc39-44ff-85ea-f114a4f33200)

Since all the child nodes of D do not fulfill the goal and has been eliminated, we look to another child node of B which is E

![image](https://github.com/user-attachments/assets/b4f27138-cf8c-4d29-af16-b5c09841a5ee)

![image](https://github.com/user-attachments/assets/1d8256e3-96cb-4c2f-a080-118e931523ac)

![image](https://github.com/user-attachments/assets/50d88ec0-ad2e-4879-9e2a-07ce2ce7c4da)

![image](https://github.com/user-attachments/assets/d8c4ce81-64d7-4736-9d2b-0fc2299eb449)

![image](https://github.com/user-attachments/assets/2559576f-4d5c-495a-9e52-259689d47009)

![image](https://github.com/user-attachments/assets/74c73752-2fe6-402f-b50e-207f8d7d60eb)

![image](https://github.com/user-attachments/assets/fb38a245-16f0-48f5-9337-701e31838264)

### Uniform cost search (DFS)

**How it works:**
1. Expand on nodes based on the cost (from the lowest to highest)
2. If there exist redundant nodes in the same level, remove the child node which have higher total cost

#### BFS vs UFS
1. Expand on nodes based on the cost (from the lowest to highest)
2. Priority queue based on path cost in frontier
3. As the goal is reached, the algorithm does not end and will continue to find lower costs to reach the goal

![image](https://github.com/user-attachments/assets/4005b763-ade1-4743-b277-1e5aac5a7f38)

![image](https://github.com/user-attachments/assets/aa143ed3-cb18-458b-ad43-7930027b171a)





