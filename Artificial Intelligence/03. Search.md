# 03. Search
Search is the process of looking for a sequence of actions that reaches the goal.

## Goal
- Goal limits the objectives to achieve and hence the actions to consider.
- Given a goal, the process of problem formulation is to decide the **actions** and **states** to
be used in the problem.

## State
- represents the current condition / situation

## Actions
- Defined as the steps taken to acheive the goal

## Solution
- Defined as a sequence of actions performed to reach the goal from the starting state
- A solution to a problem is an action sequence that leads from the initial state to the goalstate
- An optimal solution is the “best” solution among all solutions.
For

## State space
- is the representation of a problem whereby possible alternative paths leading to a solution can be explored and analysed.
- is constructed with all possible states and actions.
- starting point to creating an algorithm

![image](https://github.com/user-attachments/assets/9ed376ee-149c-428b-854c-4edb37292507)

## Transition model
- Defined as the description of each actions.
- is a function to map one state to another state given an action.

f(current state, action) = next state

![image](https://github.com/user-attachments/assets/9d973313-8289-4008-a5c9-b0f0bb745207)

## Real-world problems
1. route-finding problems – as the one of Nick in Romania
2. touring problems – visit every point at least once, starting and ending in a specific city
3. traveling salesperson problem (TSP) – a touring problem with each point must be visited exactly only once
4. VLSI layout problem – to position millions of components and connections on a chip to minimise area, maximise production,... . . .
5. robot navigation – a more general route-finding problem

## Process of solving problem using search
To solve the problem using search, we need to go through the following process:

Step 1: Goal formulation
Step 2: Problem formulation
Step 3: Solution identification

## Search algorithms
Different search algorithms are useful to identify optimal solutions with different criteria of “best”.

### Five components 
- Initial state = the state the agent starts in
- Actions – the actions available to the agent
- Transition model – description of what each action does
- Goal test – a test to determine if a given state is a goal state
- Path cost – calculate numerical cost of a path (a series of actions) to reflect performance measure

### Types of search algorithms
1. Uninformed search 
2. Informed search
3. same search

## Uninformed Search
- also known as blind search because there's no additional information provided.
- It uses strategies with no additional information beyond the problem's definition.

### Types of Uninformed Search
- Breadth-first search (BFS)
- Depth-first search (DFS)
- Uniform-cost search (UCS)

### Important terms
- Root node / Parent node = starting node
- Frontier node / leaf node = node which does not have any other options (child nodes)
  
### Breadth-first search (BFS)

**How it works:**
1. Expand root node
2. Expand all successors of root node at the **same level**
3. Continue expanding the successors of the successors

**Note:**
- If there exist redundant nodes in the same level, remove the child node which is found later

![image](https://github.com/user-attachments/assets/97cafb8e-2398-4bc1-b82c-ab5947ea9bd6)

- As the goal is reached, the algorithm ends

![image](https://github.com/user-attachments/assets/38728287-5519-44ec-a8b3-c08d9804efbd)

### Depth-first search (DFS)
- Depth-first search (DFS) expands the deepest node in the current frontier of the search tree.
- The nodes on the left regardless of each level is always the first node for the particular level.

#### Types of depth-first search 
1. Depth-limited search
- A depth limit is imposed. Nodes at the depth limit are treated as having no successors.

2. Iterative deepening depth-first search
- Iteratively changes the depth limit in order to find the shallowest depth to reach the goal.

#### Example: Reach node M using DFS

The nodes on the left regardless of each level is always the first node for the particular level. In this case, it is B,D and H.

![image](https://github.com/user-attachments/assets/57ba3501-f128-4e8b-aa82-f2a12072d6f7)

The explored nodes which do not match the goal will be eliminated

![image](https://github.com/user-attachments/assets/9fb8d32f-cc39-44ff-85ea-f114a4f33200)

Since all the child nodes of D do not fulfill the goal and has been eliminated, we look to another child node of B which is E

![image](https://github.com/user-attachments/assets/b4f27138-cf8c-4d29-af16-b5c09841a5ee)

Node E has child nodes of J and K.

![image](https://github.com/user-attachments/assets/1d8256e3-96cb-4c2f-a080-118e931523ac)

Since the child node J do not fulfill the goal, it is eliminated and we move to check child node K

![image](https://github.com/user-attachments/assets/50d88ec0-ad2e-4879-9e2a-07ce2ce7c4da)

Since all the child nodes of B do not fulfill the goal and has been eliminated, we look to another child node of A which is C

![image](https://github.com/user-attachments/assets/d8c4ce81-64d7-4736-9d2b-0fc2299eb449)

Node C has child nodes of F and G

![image](https://github.com/user-attachments/assets/2559576f-4d5c-495a-9e52-259689d47009)

Start by checking the first node of the level which if node L

![image](https://github.com/user-attachments/assets/74c73752-2fe6-402f-b50e-207f8d7d60eb)

Since the child node L do not fulfill the goal, it is eliminated and we move to check child node M. Since node M is the goal, the algorithm stops.

![image](https://github.com/user-attachments/assets/fb38a245-16f0-48f5-9337-701e31838264)

### Uniform cost search (DFS)

**How it works:**
1. Expand on nodes based on the cost (from the lowest to highest)
2. When a redundant path exists, the path with a higher path cost is removed.
3. If there exist redundant nodes in the same level, remove the child node which have higher total cost (path cost)

![image](https://github.com/user-attachments/assets/2906c49f-e072-48c2-b310-b10dfa17cdd1)

#### BFS vs UFS
1. Expand on nodes based on the cost (from the lowest to highest)
2. Priority queue based on path cost in frontier
3. As the goal is reached, the algorithm does not end and will continue to find lower costs to reach the goal

![image](https://github.com/user-attachments/assets/4005b763-ade1-4743-b277-1e5aac5a7f38)

![image](https://github.com/user-attachments/assets/aa143ed3-cb18-458b-ad43-7930027b171a)





